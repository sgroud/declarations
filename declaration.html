<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GPX → Places (Google + Map + Progress + Clusters)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <style>
    body{font-family:system-ui;max-width:1000px;margin:24px auto;padding:0 16px;color:#111}
    h1{font-size:22px;margin-bottom:8px}
    textarea{width:100%;height:140px;font-family:monospace;margin-top:8px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin:12px 0}
    .log{background:#f7f7f8;padding:12px;border-radius:8px;border:1px solid #eee;white-space:pre-wrap;max-height:240px;overflow:auto}
    #map{height:400px;margin-top:20px;border-radius:8px;border:1px solid #ccc}
    #progress-container{width:100%;background:#eee;border-radius:8px;overflow:hidden;margin:12px 0;height:16px}
    #progress{height:100%;width:0%;background:#4caf50;transition:width .25s}
  </style>
</head>
<body>
  <h1>GPX → Cities / Towns / Villages (Google Geocoding + Map + Progress)</h1>

  <div class="controls">
    <input id="gpxfile" type="file" accept=".gpx,.xml" />
    <input id="apikey" type="text" placeholder="Google Maps API key" style="min-width:220px" />
    <input id="delay" type="number" value="300" min="0" style="width:110px" />
    <label for="delay">ms delay</label>
    <button id="start">Process GPX</button>
    <button id="download" disabled>Download CSV</button>
  </div>

  <div id="progress-container"><div id="progress"></div></div>

  <label><strong>Raw GPX (first 1000 chars)</strong></label>
  <textarea id="gpxpreview" readonly></textarea>

  <h3>Map Preview</h3>
  <div id="map"></div>

  <h3>Log</h3>
  <div id="log" class="log"></div>

<script>
const $ = id => document.getElementById(id);
const logEl = $('log');
function log(...a){ logEl.textContent += a.join(' ') + '
'; logEl.scrollTop = logEl.scrollHeight; }

// GPX parsing
function parseGPX(text){
  const xml=new DOMParser().parseFromString(text,'application/xml');
  const pts=['trkpt','rtept','wpt'].flatMap(t=>Array.from(xml.querySelectorAll(t)));
  return pts.map(el=>({lat:+el.getAttribute('lat'), lon:+el.getAttribute('lon')}));
}

// RDP simplify
function getDist(pt,a,b){
  const dx=b.x-a.x, dy=b.y-a.y;
  if(!dx&&!dy) return Math.hypot(pt.x-a.x, pt.y-a.y);
  const t=((pt.x-a.x)*dx+(pt.y-a.y)*dy)/(dx*dx+dy*dy);
  const px=a.x+t*dx, py=a.y+t*dy;
  return Math.hypot(pt.x-px, pt.y-py);
}
function rdp(p,eps){
  if(p.length<3) return p;
  const f=p[0], l=p[p.length-1];
  let idx=-1, max=0;
  for(let i=1;i<p.length-1;i++){
    const d=getDist({x:p[i].lon,y:p[i].lat},{x:f.lon,y:f.lat},{x:l.lon,y:l.lat});
    if(d>max){max=d;idx=i;}
  }
  if(max>eps){
    const left=rdp(p.slice(0,idx+1),eps);
    const right=rdp(p.slice(idx),eps);
    return left.slice(0,-1).concat(right);
  }
  return [f,l];
}

// Google reverse geocode
async function reverseGoogle(lat,lon,key){
  const url=`https://maps.googleapis.com/maps/api/geocode/json?latlng=${lat},${lon}&key=${key}`;
  return fetch(url).then(r=>r.json());
}
function extractGooglePlace(j){
  if(!j.results?.length) return null;
  const c=j.results[0].address_components;
  const get=t=>{const x=c.find(v=>v.types.includes(t));return x?x.long_name:null;};
  return get('locality') || get('postal_town') || get('administrative_area_level_2') || get('administrative_area_level_1');
}

// Map init
let map, polyline, cluster;
function initMap(){
  if(map) return;
  map=L.map('map').setView([0,0],2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);
  cluster=L.markerClusterGroup();
  map.addLayer(cluster);
}
function drawTrackAnimated(points){
  if(polyline){polyline.remove();}
  const latlngs=points.map(p=>[p.lat,p.lon]);
  polyline=L.polyline([], {color:'blue'}).addTo(map);
  map.fitBounds(L.latLngBounds(latlngs));

  let i=0;
  function step(){
    if(i<latlngs.length){
      polyline.addLatLng(latlngs[i]);
      i++;
      requestAnimationFrame(step);
    }
  }
  step();
}

function drawTrack(points){
  if(polyline){polyline.remove();}
  polyline=L.polyline(points.map(p=>[p.lat,p.lon]),{color:'blue'}).addTo(map);
  map.fitBounds(polyline.getBounds());
}

function updateProgress(i,total){
  const pct=Math.round((i/total)*100);
  $('progress').style.width=pct+'%';
}

$('start').onclick=async ()=>{
  logEl.textContent='';
  $('progress').style.width='0%';
  initMap();
  cluster.clearLayers();

  const file=$('gpxfile').files[0];
  if(!file){log('No file selected');return;}
  const key=$('apikey').value.trim();
  if(!key){log('Google API key required');return;}
  const delay=+$('delay').value || 0;

  const text=await file.text();
  $('gpxpreview').value=text.slice(0,1000);
  log('GPX loaded');

  const pts=parseGPX(text);
  if(!pts.length){log('No points');return;}
  log('Points:',pts.length);
  drawTrackAnimated(pts);

  const simp=rdp(pts,0.0008);
  log('Simplified:',simp.length);

  const places=new Map();
  for(let i=0;i<simp.length;i++){
    const {lat,lon}=simp[i];
    log(`Geocoding ${i+1}/${simp.length}`);
    try{
      const j=await reverseGoogle(lat,lon,key);
      const p=extractGooglePlace(j);
      if(p && !places.has(p)){
        places.set(p,{place:p,lat,lon});
        const m=L.marker([lat,lon]).bindPopup(p);
        cluster.addLayer(m);
      }
    }catch(e){log('Error',e.message);}    
    updateProgress(i+1,simp.length);
    await new Promise(r=>setTimeout(r,delay));
  }

  const rows=[["place","lat","lon"],...places.values()].map(r=>Array.isArray(r)?r:[r.place,r.lat,r.lon]);
  const csv=rows.map(r=>r.map(c=>'"'+String(c).replace(/"/g,'""')+'"').join(',')).join('
');
  const blob=new Blob([csv],{type:'text/csv'});
  const url=URL.createObjectURL(blob);

  const dl=$('download');
  dl.disabled=false;
  dl.onclick=()=>{
    const a=document.createElement('a');
    a.href=url;
    a.download=file.name.replace(/\.gpx$/i,'')+'_places.csv';
    a.click();
  };

  log('Done. Found '+places.size+' places.');
};
</script>
</body>
</html>
